{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Accueil","text":"Accueil"},{"location":"#pymdu-python-modele-de-donnees-urbain","title":"Pymdu (Python Mod\u00e8le de Donn\u00e9es Urbain)","text":"<p> Pymdu (Mod\u00e8le de Donn\u00e9es Urbain) est un package Python con\u00e7u pour collecter, post-traiter, mod\u00e9liser et analyser des donn\u00e9es urbaines. Il s'inspire et r\u00e9utilise des outils comme GeoClimate, UWG, UMEP-DEV, t4gpd, et pythermalcomfort pour offrir une solution compl\u00e8te \u00e0 l'analyse de l'environnement urbain. Une application cl\u00e9 de pymdu est l'analyse du confort thermique ext\u00e9rieur, permettant de simuler et d'optimiser les espaces urbains pour am\u00e9liorer le bien-\u00eatre des habitants. </p>"},{"location":"#credits","title":"Credits","text":"<p>Created by Tipee</p> <p>Generated by MkDocs</p>"},{"location":"demo_data_inputs/","title":"Demo data inputs","text":"Demo data inputs In\u00a0[1]: Copied! <pre>import os\ntry:\n    import scienceplots\n    plt.style.use(['science', 'ieee', 'notebook', 'no-latex'])\nexcept:pass\nimport sys\nsys.path.append(os.path.dirname(os.getcwd()))\n</pre> import os try:     import scienceplots     plt.style.use(['science', 'ieee', 'notebook', 'no-latex']) except:pass import sys sys.path.append(os.path.dirname(os.getcwd())) In\u00a0[2]: Copied! <pre>from pymdu.commons.BasicFunctions import draw_bbox_with_folium\ndraw_bbox_with_folium(lat=46.160329,\n                      lon=-1.151139,\n                      zoom_start=13)\n</pre> from pymdu.commons.BasicFunctions import draw_bbox_with_folium draw_bbox_with_folium(lat=46.160329,                       lon=-1.151139,                       zoom_start=13) <pre>TEMP_PATH /var/folders/zh/f2j36cz90lzfcn8r42snc4nc0000gr/T\n</pre> In\u00a0[3]: Copied! <pre>geojson_dict = {\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[-1.155502,46.179057],[-1.155502,46.186278],[-1.14362,46.186278],[-1.14362,46.179057],[-1.155502,46.179057]]]}}\n</pre> geojson_dict = {\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[-1.155502,46.179057],[-1.155502,46.186278],[-1.14362,46.186278],[-1.14362,46.179057],[-1.155502,46.179057]]]}} In\u00a0[4]: Copied! <pre># Extraire les coordonn\u00e9es du polygone\ncoordinates = geojson_dict['geometry']['coordinates'][0]\n# Calculer les valeurs min et max\nminx = min([point[0] for point in coordinates])  # Minimum des longitudes (x)\nminy = min([point[1] for point in coordinates])  # Minimum des latitudes (y)\nmaxx = max([point[0] for point in coordinates])  # Maximum des longitudes (x)\nmaxy = max([point[1] for point in coordinates])  # Maximum des latitudes (y)\n# Cr\u00e9er la liste [minx, miny, maxx, maxy]\nbbox_coords = [minx, miny, maxx, maxy]\n</pre> # Extraire les coordonn\u00e9es du polygone coordinates = geojson_dict['geometry']['coordinates'][0] # Calculer les valeurs min et max minx = min([point[0] for point in coordinates])  # Minimum des longitudes (x) miny = min([point[1] for point in coordinates])  # Minimum des latitudes (y) maxx = max([point[0] for point in coordinates])  # Maximum des longitudes (x) maxy = max([point[1] for point in coordinates])  # Maximum des latitudes (y) # Cr\u00e9er la liste [minx, miny, maxx, maxy] bbox_coords = [minx, miny, maxx, maxy] In\u00a0[5]: Copied! <pre>bbox_coords\n</pre> bbox_coords Out[5]: <pre>[-1.155502, 46.179057, -1.14362, 46.186278]</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[6]: Copied! <pre>import os\nfrom pymdu.commons.BasicFunctions import extract_coordinates_from_filenames, get_intersection_with_bbox, \\\n    get_intersection_with_bbox_and_attributes\n\ndirectory_path = os.path.join(\"D:\\\\CoSIA_D017_2021\\\\CoSIA_D017_2021\")\ngdf_coordinates = extract_coordinates_from_filenames(directory_path)\nintersection_gdf = get_intersection_with_bbox(gdf_coordinates, bbox_coords)\ncosia = get_intersection_with_bbox_and_attributes(gdf_coordinates, bbox_coords, directory_path)\n</pre> import os from pymdu.commons.BasicFunctions import extract_coordinates_from_filenames, get_intersection_with_bbox, \\     get_intersection_with_bbox_and_attributes  directory_path = os.path.join(\"D:\\\\CoSIA_D017_2021\\\\CoSIA_D017_2021\") gdf_coordinates = extract_coordinates_from_filenames(directory_path) intersection_gdf = get_intersection_with_bbox(gdf_coordinates, bbox_coords) cosia = get_intersection_with_bbox_and_attributes(gdf_coordinates, bbox_coords, directory_path)  <pre>\n---------------------------------------------------------------------------\nFileNotFoundError                         Traceback (most recent call last)\nCell In[6], line 6\n      2 from pymdu.commons.BasicFunctions import extract_coordinates_from_filenames, get_intersection_with_bbox, \\\n      3     get_intersection_with_bbox_and_attributes\n      5 directory_path = os.path.join(\"D:\\\\CoSIA_D017_2021\\\\CoSIA_D017_2021\")\n----&gt; 6 gdf_coordinates = extract_coordinates_from_filenames(directory_path)\n      7 intersection_gdf = get_intersection_with_bbox(gdf_coordinates, bbox_coords)\n      8 cosia = get_intersection_with_bbox_and_attributes(gdf_coordinates, bbox_coords, directory_path)\n\nFile ~/Documents/TIPEE/pymdu_public/pymdu/commons/BasicFunctions.py:431, in extract_coordinates_from_filenames(directory_path, departement_code)\n    428 pattern = re.compile(rf'D0{departement_code}_2021_(\\d+)_(\\d+)_vecto\\.gpkg')\n    430 # Parcourir tous les fichiers dans le dossier sp\u00e9cifi\u00e9\n--&gt; 431 for filename in os.listdir(directory_path):\n    432     if filename.endswith('.gpkg'):\n    433         match = pattern.match(filename)\n\nFileNotFoundError: [Errno 2] No such file or directory: 'D:\\\\CoSIA_D017_2021\\\\CoSIA_D017_2021'</pre> In\u00a0[7]: Copied! <pre>table_color_cosia = {\"B\u00e2timent\" : \"#ce7079\",\n\"Zone imperm\u00e9able\" :\"#a6aab7\",\n\"Zone perm\u00e9able\":\"#987752\",\n\"Piscine\":\"#62d0ff\",\n\"Serre\":\"#b9e2d4\",\n\"Sol nu\":\"#bbb096\",\n\"Surface eau\":\"#3375a1\",\n\"Neige\":\"#e9effe\",\n\"Conif\u00e8re\":\"#216e2e\",\n\"Feuillu\":\"#4c9129\",\n\"Coupe\": \"#e48e4d\",\n\"Broussaille\":\"#b5c335\",\n\"Pelouse\": \"#8cd76a\",\n\"Culture\":\"#decf55\",\n\"Terre labour\u00e9e\":\"#d0a349\",\n\"Vigne\":\"#b08290\",\n\"Autre\":\"#222222\"}\n</pre> table_color_cosia = {\"B\u00e2timent\" : \"#ce7079\", \"Zone imperm\u00e9able\" :\"#a6aab7\", \"Zone perm\u00e9able\":\"#987752\", \"Piscine\":\"#62d0ff\", \"Serre\":\"#b9e2d4\", \"Sol nu\":\"#bbb096\", \"Surface eau\":\"#3375a1\", \"Neige\":\"#e9effe\", \"Conif\u00e8re\":\"#216e2e\", \"Feuillu\":\"#4c9129\", \"Coupe\": \"#e48e4d\", \"Broussaille\":\"#b5c335\", \"Pelouse\": \"#8cd76a\", \"Culture\":\"#decf55\", \"Terre labour\u00e9e\":\"#d0a349\", \"Vigne\":\"#b08290\", \"Autre\":\"#222222\"} In\u00a0[8]: Copied! <pre>cosia['color'] = [table_color_cosia[x] for x in cosia.classe]\n</pre> cosia['color'] = [table_color_cosia[x] for x in cosia.classe] <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 cosia['color'] = [table_color_cosia[x] for x in cosia.classe]\n\nNameError: name 'cosia' is not defined</pre> In\u00a0[9]: Copied! <pre>import os\nimport re\nimport matplotlib.patches as mpatches\nfrom pymdu.geometric.Lcz import Lcz\nimport matplotlib.pyplot as plt\n\n\n# D\u00e9finir la table de correspondance des couleurs et descriptions\ntable_color_cosia = {\"B\u00e2timent\" : \"#ce7079\",\n\"Zone imperm\u00e9able\" :\"#a6aab7\",\n\"Zone perm\u00e9able\":\"#987752\",\n\"Piscine\":\"#62d0ff\",\n\"Serre\":\"#b9e2d4\",\n\"Sol nu\":\"#bbb096\",\n\"Surface eau\":\"#3375a1\",\n\"Neige\":\"#e9effe\",\n\"Conif\u00e8re\":\"#216e2e\",\n\"Feuillu\":\"#4c9129\",\n\"Coupe\": \"#e48e4d\",\n\"Broussaille\":\"#b5c335\",\n\"Pelouse\": \"#8cd76a\",\n\"Culture\":\"#decf55\",\n\"Terre labour\u00e9e\":\"#d0a349\",\n\"Vigne\":\"#b08290\",\n\"Autre\":\"#222222\"}\n\n# Tracer le GeoDataFrame\nfig, ax = plt.subplots(figsize=(10, 10))\ncosia.plot(ax=ax, edgecolor=None, color=cosia['color'])\ndef supprimer_caracteres_speciaux(chaine):\n    # Utilise une expression r\u00e9guli\u00e8re pour supprimer tout ce qui n'est pas un caract\u00e8re alphanum\u00e9rique\n    return re.sub(r'[^a-zA-Z0-9]', '', chaine)\n# Cr\u00e9er les patches pour chaque couleur et sa description dans la l\u00e9gende\npatches = [mpatches.Patch(color=value, label=supprimer_caracteres_speciaux(label)) for (value, label) in zip(table_color_cosia.values(),\n                                                                        table_color_cosia.keys())]\n\n# Ajouter la l\u00e9gende personnalis\u00e9e\nplt.legend(handles=patches, loc='upper right', title='Cosia Legend',bbox_to_anchor = (1.5,1.))\n\n\n# Afficher la carte avec la l\u00e9gende\nplt.show()\n\n# Sauvegarder l'image\nplt.savefig(\"cosia.png\", format=\"png\", dpi=199)\n</pre> import os import re import matplotlib.patches as mpatches from pymdu.geometric.Lcz import Lcz import matplotlib.pyplot as plt   # D\u00e9finir la table de correspondance des couleurs et descriptions table_color_cosia = {\"B\u00e2timent\" : \"#ce7079\", \"Zone imperm\u00e9able\" :\"#a6aab7\", \"Zone perm\u00e9able\":\"#987752\", \"Piscine\":\"#62d0ff\", \"Serre\":\"#b9e2d4\", \"Sol nu\":\"#bbb096\", \"Surface eau\":\"#3375a1\", \"Neige\":\"#e9effe\", \"Conif\u00e8re\":\"#216e2e\", \"Feuillu\":\"#4c9129\", \"Coupe\": \"#e48e4d\", \"Broussaille\":\"#b5c335\", \"Pelouse\": \"#8cd76a\", \"Culture\":\"#decf55\", \"Terre labour\u00e9e\":\"#d0a349\", \"Vigne\":\"#b08290\", \"Autre\":\"#222222\"}  # Tracer le GeoDataFrame fig, ax = plt.subplots(figsize=(10, 10)) cosia.plot(ax=ax, edgecolor=None, color=cosia['color']) def supprimer_caracteres_speciaux(chaine):     # Utilise une expression r\u00e9guli\u00e8re pour supprimer tout ce qui n'est pas un caract\u00e8re alphanum\u00e9rique     return re.sub(r'[^a-zA-Z0-9]', '', chaine) # Cr\u00e9er les patches pour chaque couleur et sa description dans la l\u00e9gende patches = [mpatches.Patch(color=value, label=supprimer_caracteres_speciaux(label)) for (value, label) in zip(table_color_cosia.values(),                                                                         table_color_cosia.keys())]  # Ajouter la l\u00e9gende personnalis\u00e9e plt.legend(handles=patches, loc='upper right', title='Cosia Legend',bbox_to_anchor = (1.5,1.))   # Afficher la carte avec la l\u00e9gende plt.show()  # Sauvegarder l'image plt.savefig(\"cosia.png\", format=\"png\", dpi=199)  <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 29\n     27 # Tracer le GeoDataFrame\n     28 fig, ax = plt.subplots(figsize=(10, 10))\n---&gt; 29 cosia.plot(ax=ax, edgecolor=None, color=cosia['color'])\n     30 def supprimer_caracteres_speciaux(chaine):\n     31     # Utilise une expression r\u00e9guli\u00e8re pour supprimer tout ce qui n'est pas un caract\u00e8re alphanum\u00e9rique\n     32     return re.sub(r'[^a-zA-Z0-9]', '', chaine)\n\nNameError: name 'cosia' is not defined</pre> In\u00a0[10]: Copied! <pre>cosia\n</pre> cosia <pre>\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 cosia\n\nNameError: name 'cosia' is not defined</pre> In\u00a0[11]: Copied! <pre>import os\nimport matplotlib.patches as mpatches\nfrom pymdu.geometric.Lcz import Lcz\nimport matplotlib.pyplot as plt\n\n# Cr\u00e9er l'objet LCZ et g\u00e9n\u00e9rer le GeoDataFrame\nlcz = Lcz()\nlcz.bbox = [-1.160563, 46.17713, -1.138726, 46.188893]\nlcz_gdf = lcz.run().to_gdf()\n\n# D\u00e9finir la table de correspondance des couleurs et descriptions\ntable_color = {\n    1: ['LCZ 1: Compact high-rise', '#8b0101'],\n    2: ['LCZ 2: Compact mid-rise', '#cc0200'],\n    3: ['LCZ 3: Compact low-rise', '#fc0001'],\n    4: ['LCZ 4: Open high-rise', '#be4c03'],\n    5: ['LCZ 5: Open mid-rise', '#ff6602'],\n    6: ['LCZ 6: Open low-rise', '#ff9856'],\n    7: ['LCZ 7: Lightweight low-rise', '#fbed08'],\n    8: ['LCZ 8: Large low-rise', '#bcbcba'],\n    9: ['LCZ 9: Sparsely built', '#ffcca7'],\n    10: ['LCZ 10: Heavy industry', '#57555a'],\n    11: ['LCZ A: Dense trees', '#006700'],\n    12: ['LCZ B: Scattered trees', '#05aa05'],\n    13: ['LCZ C: Bush,scrub', '#648423'],\n    14: ['LCZ D: Low plants', '#bbdb7a'],\n    15: ['LCZ E: Bare rock or paved', '#010101'],\n    16: ['LCZ F: Bare soil or sand', '#fdf6ae'],\n    17: ['LCZ G: Water', '#6d67fd']\n}\n\n# Tracer le GeoDataFrame\nfig, ax = plt.subplots(figsize=(10, 10))\nlcz_gdf.plot(ax=ax, edgecolor='w', color=lcz_gdf['color'])\n# Cr\u00e9er les patches pour chaque couleur et sa description dans la l\u00e9gende\npatches = [mpatches.Patch(color=info[1], label=info[0]) for info in table_color.values()]\n\n# Ajouter la l\u00e9gende personnalis\u00e9e\nplt.legend(handles=patches, loc='upper right', title='LCZ Legend',bbox_to_anchor = (1.5,1.))\n\n\n# Afficher la carte avec la l\u00e9gende\nplt.show()\n\n# Sauvegarder l'image\nplt.savefig(\"gdf_lcz.png\", format=\"png\", dpi=199)\n</pre> import os import matplotlib.patches as mpatches from pymdu.geometric.Lcz import Lcz import matplotlib.pyplot as plt  # Cr\u00e9er l'objet LCZ et g\u00e9n\u00e9rer le GeoDataFrame lcz = Lcz() lcz.bbox = [-1.160563, 46.17713, -1.138726, 46.188893] lcz_gdf = lcz.run().to_gdf()  # D\u00e9finir la table de correspondance des couleurs et descriptions table_color = {     1: ['LCZ 1: Compact high-rise', '#8b0101'],     2: ['LCZ 2: Compact mid-rise', '#cc0200'],     3: ['LCZ 3: Compact low-rise', '#fc0001'],     4: ['LCZ 4: Open high-rise', '#be4c03'],     5: ['LCZ 5: Open mid-rise', '#ff6602'],     6: ['LCZ 6: Open low-rise', '#ff9856'],     7: ['LCZ 7: Lightweight low-rise', '#fbed08'],     8: ['LCZ 8: Large low-rise', '#bcbcba'],     9: ['LCZ 9: Sparsely built', '#ffcca7'],     10: ['LCZ 10: Heavy industry', '#57555a'],     11: ['LCZ A: Dense trees', '#006700'],     12: ['LCZ B: Scattered trees', '#05aa05'],     13: ['LCZ C: Bush,scrub', '#648423'],     14: ['LCZ D: Low plants', '#bbdb7a'],     15: ['LCZ E: Bare rock or paved', '#010101'],     16: ['LCZ F: Bare soil or sand', '#fdf6ae'],     17: ['LCZ G: Water', '#6d67fd'] }  # Tracer le GeoDataFrame fig, ax = plt.subplots(figsize=(10, 10)) lcz_gdf.plot(ax=ax, edgecolor='w', color=lcz_gdf['color']) # Cr\u00e9er les patches pour chaque couleur et sa description dans la l\u00e9gende patches = [mpatches.Patch(color=info[1], label=info[0]) for info in table_color.values()]  # Ajouter la l\u00e9gende personnalis\u00e9e plt.legend(handles=patches, loc='upper right', title='LCZ Legend',bbox_to_anchor = (1.5,1.))   # Afficher la carte avec la l\u00e9gende plt.show()  # Sauvegarder l'image plt.savefig(\"gdf_lcz.png\", format=\"png\", dpi=199)  <pre>&lt;Figure size 640x480 with 0 Axes&gt;</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"demo_data_inputs/#recuperer-le-bboxdu-projet","title":"R\u00e9cup\u00e9rer le <code>bbox</code>du projet\u00b6","text":"<p>La bounding box <code>bbox</code> est une bo\u00eete englobante d\u00e9finie par des coordonn\u00e9es g\u00e9ographiques qui d\u00e9limitent une zone rectangulaire sur une carte. Elle est couramment utilis\u00e9e pour sp\u00e9cifier une r\u00e9gion d'int\u00e9r\u00eat et faciliter le traitement g\u00e9ospatial de cette zone.</p> <ul> <li>Dessiner un rectangle sur la carte</li> <li>Cliquer sur le rectangle</li> <li>Copier/Coller la chaine de caract\u00e8re qui s'affiche dans une variable python <code>bbox_str</code></li> </ul> <pre><code>{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[-1.167492,46.170665],[-1.167492,46.179228],[-1.144669,46.179228],[-1.144669,46.170665],[-1.167492,46.170665]]]}}\n</code></pre>"},{"location":"demo_data_inputs/#telecharger-des-donnees","title":"T\u00e9l\u00e9charger des donn\u00e9es\u00b6","text":""},{"location":"demo_data_inputs/#la-bdtopo","title":"La BDTOPO\u00b6","text":""},{"location":"demo_data_inputs/#loccupation-du-sol-avec-cosia","title":"L'occupation du sol avec COSIA\u00b6","text":"<p>https://cosia.ign.fr/info#export</p> <p>Pr\u00e9-requis : avoir t\u00e9l\u00e9charg\u00e9 les donn\u00e9es <code>.gpkg</code> du d\u00e9partement ad\u00e9quat</p>"},{"location":"demo_data_inputs/#les-lcz","title":"Les LCZ\u00b6","text":""},{"location":"documentation/","title":"Documentation","text":"Documentation"},{"location":"documentation/#construire-la-documentation","title":"Construire la documentation","text":"<p>Pour g\u00e9n\u00e9rer la documentation en local avec ce projet, suivez les \u00e9tapes ci-dessous :</p> <ol> <li>Cloner le projet : <code>git clone https://github.com/rupeelab17/pymdu.git</code></li> <li>Pr\u00e9visualisez la documentation : <code>mkdocs serve</code></li> <li>La documentation sera accessible \u00e0 l'adresse suivante : <code>http://127.0.0.1:8000/mdu/pymdu/site/</code>.</li> <li>Ajouter du contenu dans les doctrings pour la documentation des classes et m\u00e9thodes.</li> <li>G\u00e9n\u00e9rer le site web : <code>mkdocs build</code>.</li> </ol>"},{"location":"documentation/#formater-son-code-avec-les-doctrings-google-style","title":"Formater son code avec les Doctrings : Google Style","text":"Google styleExemple <pre><code>def function_name(param1: Type1, param2: Type2, ...) -&gt; ReturnType:\n    \"\"\"Brief description of the function.\n\n    More detailed explanation of the function if necessary. This can span\n    multiple lines as needed.\n\n    Args:\n       param1 (Type1): Description of param1.\n       param2 (Type2): Description of param2.\n       ...\n\n    Returns:\n       ReturnType: Description of the return value.\n\n    Raises:\n       ExceptionType: Explanation of the conditions under which this exception is raised.\n\n    Example:\n       ```python exec=\"false\" source=\"tabbed-right\" html=\"1\" tabs=\"Source code|Plot\"\n       function_name(param1_value, param2_value)\n       ```\n    \"\"\"\n</code></pre> <pre><code>def add_numbers(num1: int, num2: int = 5) -&gt; int:\n   \"\"\"Adds two numbers together.\n\n   Args:\n       num1 (int): The first number to add.\n       num2 (int, optional): The second number to add. Defaults to 5.\n\n   Returns:\n       int: The sum of num1 and num2.\n\n   Example:\n       ```python exec=\"false\" source=\"tabbed-right\" html=\"1\" tabs=\"Source code|Plot\"\n        add_numbers(3, 2)\n       ```\n   \"\"\"\n   return num1 + num2\n</code></pre>"},{"location":"documentation/#aide","title":"Aide","text":"<p>Documentation de mkdocs</p> <p>https://squidfunk.github.io/mkdocs-material/reference/formatting/</p> <p>TIPS</p> <p>Generated by MkDocs</p>"},{"location":"installation/","title":"Installation","text":"Installation <p>Pr\u00e9requis</p> Installation de java 11Installation de micromambaInstallation de git <p>java Windows OS et Mac OS</p> <p>micromamba Windows OS et Mac OS</p> <p>git Windows OS et Mac OS</p>"},{"location":"installation/#1-installation-de-pymdu","title":"1. Installation de pymdu","text":""},{"location":"installation/#11-rapatrier-le-depot-git","title":"1.1. Rapatrier le d\u00e9p\u00f4t git","text":"<pre><code>git clone https://github.com/rupeelab17/pymdu.git\n</code></pre>"},{"location":"installation/#12-installation-de-lenvironnement-python","title":"1.2. Installation de l'environnement python","text":"<pre><code>cd pymdu\nmicromamba env create -f environment.yml # (1)!\nmicromamba activate pymdu\nmicromamba install git pip uv\nmicromamba install qgis -c micromamba-forge\nmicromamba install fiona -c micromamba-forge\n</code></pre> <ol> <li> L'environnement python est cr\u00e9\u00e9 en local.</li> </ol> environment.yml <pre><code>name: pymdu\nchannels:\n  - conda-forge\n    - defaults\n    - numba\ndependencies:\n    - python=3.11\n    - rasterio\n    - gdal\n    - openjpeg\n    - llvmlite\n</code></pre>"},{"location":"installation/#13-installation-du-package-pour-le-developpement","title":"1.3. Installation du package pour le d\u00e9veloppement","text":"<pre><code>cd pymdu\nuv pip install poetry\npoetry self add \"poetry-dynamic-versioning[plugin]\"\npython -m poetry install --with docs\npoetry export -f requirements.txt --output requirements.txt --without-hashes --with docs\nuv pip install -r requirements.txt\n</code></pre>"},{"location":"installation/#2-installation-de-pymdu-avec-docker","title":"2. Installation de pymdu avec Docker","text":""},{"location":"installation/#21-installation-de-docker","title":"2.1. Installation de Docker","text":"Windows OSMac OS <p>https://docs.docker.com/desktop/install/windows-install/</p> <p>https://docs.docker.com/desktop/install/mac-install/</p>"},{"location":"installation/#22-rapatrier-le-depot-git","title":"2.2. Rapatrier le d\u00e9p\u00f4t git","text":"<pre><code>git clone https://github.com/rupeelab17/pymdu.gi\ncd pymdu\n</code></pre>"},{"location":"installation/#23-construction-de-limage-docker","title":"2.3. Construction de l'image Docker","text":"<pre><code>DOCKER_BUILDKIT=1 docker build --platform linux/amd64 -t tipee/pymdu:latest .\n</code></pre>"},{"location":"installation/#24-execution-du-conteneur","title":"2.4. Ex\u00e9cution du conteneur","text":""},{"location":"installation/#sur-macos-ou-linux","title":"Sur MacOS ou Linux","text":"Premi\u00e8re m\u00e9thodeSeconde m\u00e9thode <pre><code>docker run --name pymdu --rm -it -p 8898:8898 -v \"$(pwd)\"/demos:/app/demos tipee/pymdu:latest\n</code></pre> <pre><code>docker create --name pymdu -p 8898:8898 -v \"$(pwd)\"/demos:/app/demos tipee/pymdu:latest\ndocker start pymdu\ndocker stop pymdu\n</code></pre>"},{"location":"installation/#sur-windows","title":"Sur Windows","text":"Premi\u00e8re m\u00e9thodeSeconde m\u00e9thode <pre><code>docker run --name pymdu --rm -it -p 8898:8898 -v %cd%/demos:/app/demos tipee/pymdu:latest\n</code></pre> <pre><code>docker create --name pymdu -p 8898:8898 -v %cd%:/app tipee/pymdu:latest\ndocker start pymdu\ndocker stop pymdu\n</code></pre> <p>Utilisation du container</p> <p>http://localhost:8898/</p>"},{"location":"installation/#3-compression-et-conversion-des-images-tiff","title":"3. Compression et conversion des images Tiff","text":"<pre><code>gdal_translate -of GTiff Tmrt_1997_157_0700D.tif  Tmrt_1997_157_0700D_comp.tif -co COMPRESS=DEFLATE -co PREDICTOR=2 -co DISCARD_LSB=2\n</code></pre>"},{"location":"installation/#31-convertir-tiff-en-jpeg2000","title":"3.1. Convertir Tiff en Jpeg2000","text":"<pre><code>micromamba install -c micromamba-forge openjpeg\npip install git+https://github.com/bodleian/image-processing.git\n</code></pre>"},{"location":"installation/#32-convertir-tiff-32bit-en-16bit","title":"3.2. Convertir Tiff 32bit en 16bit","text":"<pre><code>gdal_calc.py -A Tmrt_1997_157_0700D_comp.tif --outfile=out_round_multiplie.tif --calc=\"round(A,3)*1000\" \ngdal_translate -of GTiff -ot int16 out_round_multiplie.tif out_round_multiplie_16bits.tif\nopj_compress -i out_round_multiplie_16bits.tif -o out_round_multiplie_16bits.jp2\ngdal_translate -of GTiff -ot float32 out_round_multiplie_16bits.jp2 Tmrt_1997_157_0700D_32bit.tif\ngdal_calc.py -A Tmrt_1997_157_0700D_32bit.tif --outfile=Tmrt_1997_157_0700D_final.tif --calc=\"A/1000\"\n</code></pre>"},{"location":"installation/#33-convertir-tiff-16bit-en-jpeg2000-avec-python","title":"3.3. Convertir Tiff 16bit en Jpeg2000 avec Python","text":"<pre><code>from image_processing import openjpeg\n\nopj = openjpeg.OpenJpeg(openjpeg_base_path=\"/Users/Boris/anamicromamba3/envs/pymdu/bin/opj_compress\")\nopj.opj_compress(\"Tmrt_1997_157_0700D_16bit.tif\", \"Tmrt_1997_157_0700D.jp2\",\n                 openjpeg_options=openjpeg.DEFAULT_LOSSLESS_COMPRESS_OPTIONS)\n</code></pre> <p>Generated by MkDocs</p>"},{"location":"references/","title":"API R\u00e9f\u00e9rences","text":"API R\u00e9f\u00e9rences"},{"location":"references/#pymdugeometric","title":"pymdu.geometric","text":"pymdu.geometric"},{"location":"references/#pymdu.geometric","title":"pymdu.geometric","text":""},{"location":"references/#pymdu.geometric.Building","title":"Building","text":""},{"location":"references/#pymdu.geometric.Building.Building","title":"Building","text":"<pre><code>Building(\n    filepath_shp=None,\n    output_path=None,\n    defaultStoreyHeight=3,\n    set_crs=None,\n)\n</code></pre> <p>               Bases: <code>IgnCollect</code></p> <p>Class to collect the Building data.</p> <p>This class provides a method to read and process building data from a shapefile or GeoJSON file. It also calculates the mean height of the buildings, as well as their area and centroid.</p> <p>Args: filepath_shp (str): The file path to the shapefile. output_path (str): The output path for the processed data. If not provided, a default temporary path will be used. defaultStoreyHeight (float): The default height of each storey. set_crs (int): The CRS (Coordinate Reference System) to be set.</p> Example PlotSource code <p> 2025-01-21T17:01:39.022448 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\n\nimport pymdu.geometric.Building as Building\n\nbuildings = Building(output_path='./')\nbuildings.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nbuildings = buildings.run()\nbuildings.to_gdf().plot(\n    ax=plt.gca(),\n    edgecolor='black',\n    column='hauteur',\n    legend=True,\n    legend_kwds={'label': 'Hauteur', 'orientation': 'vertical'},\n)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Cadastre","title":"Cadastre","text":""},{"location":"references/#pymdu.geometric.Cadastre.Cadastre","title":"Cadastre","text":"<pre><code>Cadastre(output_path=None)\n</code></pre> <p>               Bases: <code>IgnCollect</code></p> <p>Class representing the Cadastre data collection.</p> <pre><code>output_path (str): The output path for the processed data. If not provided, a default temporary path will be used.\n</code></pre> Example PlotSource code <p> 2025-01-21T17:01:39.756770 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport pymdu.geometric.Cadastre as Cadastre\n\ncadastre = Cadastre(output_path='./')\ncadastre.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\ncadastre = cadastre.run()\ngdf = cadastre.to_gdf()\ngdf.plot(ax=plt.gca(), edgecolor='black', column='idu')\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Cosia","title":"Cosia","text":""},{"location":"references/#pymdu.geometric.Cosia.Cosia","title":"Cosia","text":"<pre><code>Cosia(output_path=None, template_raster_path=None)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> <p>A class used to collect and process Cosia data.</p> <p>This class provides methods for importing GeoPackage files into a PostgreSQL database, retrieving geodata from specified departments within a bounding box, creating landcover rasters, and overlapping with pedestrian areas. It also includes functionalities for creating trees and their positions based on the Cosia data.</p> ATTRIBUTE DESCRIPTION <code>cosia_keys</code> <p>A dictionary containing Cosia keys.</p> <p> TYPE: <code>dict</code> </p> <code>output_path</code> <p>The output path for processed data.</p> <p> TYPE: <code>str</code> </p> <code>template_raster_path</code> <p>The default height of each storey.</p> <p> TYPE: <code>str</code> </p> <code>gdf</code> <p>The GeoDataFrame containing the geodata.</p> <p> TYPE: <code>GeoDataFrame</code> </p> PARAMETER DESCRIPTION <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>template_raster_path</code> <p>The default height of each storey.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Example <p>```python exec=\"false\" source=\"tabbed-right\" html=\"1\" tabs=\"Source code|Plot\" import matplotlib.pyplot as plt</p> <p>plt.clf()  # markdown-exec: hide cosia = Cosia(output_path='./') cosia.bbox = [-1.15643, 46.16123, -1.15127, 46.16378] cosia_gdf = cosia.run().to_gdf() cosia_gdf.plot(color=cosia_gdf['color']) cosia_gdf.plot(ax=plt.gca()) from io import StringIO  # markdown-exec: hide</p> <p>buffer = StringIO()  # markdown-exec: hide plt.gcf().set_size_inches(10, 5)  # markdown-exec: hide plt.savefig(buffer, format='svg', dpi=199)  # markdown-exec: hide print(buffer.getvalue())  # markdown-exec: hide ```</p> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Cosia.Cosia.create_trees_from_cosia","title":"create_trees_from_cosia","text":"<pre><code>create_trees_from_cosia(\n    geom_col=\"geometry\",\n    height=6.0,\n    type=2,\n    trunk_zone=3.0,\n    diameter=4.0,\n    resolution=13,\n)\n</code></pre>"},{"location":"references/#pymdu.geometric.Dem","title":"Dem","text":""},{"location":"references/#pymdu.geometric.Dem.Dem","title":"Dem","text":"<pre><code>Dem(output_path=None)\n</code></pre> <p>               Bases: <code>IgnCollect</code></p> <p>Class to collect the Dem data</p> PARAMETER DESCRIPTION <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <p>Example:     PlotSource code <p> 2025-01-21T17:01:41.238241 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\n\nimport pymdu.geometric.Dem as Dem\nimport rasterio\nimport rasterio.plot\n\ndem = Dem(output_path='./')\ndem.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nign_dem = dem.run()\nfig, ax = plt.subplots(figsize=(15, 15))\nraster = rasterio.open('DEM.tif')\nrasterio.plot.show(raster, ax=ax, cmap='viridis')\n</code></pre> </p> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.DetectionUrbanTypes","title":"DetectionUrbanTypes","text":""},{"location":"references/#pymdu.geometric.DetectionUrbanTypes.DetectionUrbanTypes","title":"DetectionUrbanTypes","text":"<pre><code>DetectionUrbanTypes(output_path=None)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> PARAMETER DESCRIPTION <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Example PlotSource code <p> 2025-01-21T17:01:57.914613 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport pymdu.geometric.DetectionUrbanTypes as DetectionUrbanTypes\n\ndetection = DetectionUrbanTypes(output_path='./')\ndetection.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\ndetection = detection.run()\ngdf = detection.to_gdf()\ngdf.plot(\n    ax=plt.gca(),\n    column='cluster',\n    categorical=True,\n    figsize=(16, 16),\n    legend=True,\n)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Dpe","title":"Dpe","text":""},{"location":"references/#pymdu.geometric.Dpe.Dpe","title":"Dpe","text":"<pre><code>Dpe(output_path=None)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> <p>Class to collect the Cadastre data</p> PARAMETER DESCRIPTION <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Example PlotSource code <p> 2025-01-21T17:01:59.277528 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport pymdu.geometric.Dpe as Dpe\nimport pymdu.geometric.Building as Building\n\ndpe = Dpe()\ndpe.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\ndpe_gdf = dpe.run().to_gdf()\ntable_color = dpe.table_color\nbuildings = Building(output_path='./')\nbuildings.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nbuildings_gdf = buildings.run().to_gdf()\n# color_mapping = {\"category1\": \"green\", \"category2\": \"red\"}\nax = dpe_gdf.plot(\n    ax=plt.gca(),\n    edgecolor='black',\n    categorical=True,\n    column='classe_consommation_energie',\n    legend=True,\n    color=dpe_gdf['color'],\n)\npatches = [\n    mpatches.Patch(color=info[1], label=info[0])\n    for info in table_color.values()\n]\nplt.legend(\n    handles=patches,\n    loc='upper right',\n    title='Etiquette DPE',\n    bbox_to_anchor=(1.1, 1.0),\n)\nbuildings_gdf.plot(ax=ax, edgecolor='black', alpha=0.5)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Dxf2Shp","title":"Dxf2Shp","text":""},{"location":"references/#pymdu.geometric.Dxf2Shp.create_circle","title":"create_circle","text":"<pre><code>create_circle(center, radius, num_segments=36)\n</code></pre> <p>Cr\u00e9er un polygone approximant un cercle.</p> <p>:param center: Tuple (x, y) repr\u00e9sentant les coordonn\u00e9es du centre. :param radius: Rayon du cercle. :param num_segments: Nombre de segments pour approximer le cercle. :return: G\u00e9om\u00e9trie OGR de type POLYGON.</p>"},{"location":"references/#pymdu.geometric.Dxf2Shp.calculate_centroid","title":"calculate_centroid","text":"<pre><code>calculate_centroid(geometry)\n</code></pre> <p>Calculer le centro\u00efde ou le point moyen d'une g\u00e9om\u00e9trie MultiLineString25D.</p> <p>:param geometry: G\u00e9om\u00e9trie OGR de type wkbMultiLineString25D. :return: Tuple (x, y) repr\u00e9sentant le centro\u00efde.</p>"},{"location":"references/#pymdu.geometric.Dxf2Shp.calculate_circumscribed_circle_radius","title":"calculate_circumscribed_circle_radius","text":"<pre><code>calculate_circumscribed_circle_radius(geometry)\n</code></pre> <p>Calculer le rayon du cercle circonscrit \u00e0 une g\u00e9om\u00e9trie donn\u00e9e.</p> <p>:param geometry: G\u00e9om\u00e9trie OGR (par ex., wkbMultiLineString25D). :return: Rayon du cercle circonscrit.</p>"},{"location":"references/#pymdu.geometric.Dxf2Shp.dxf_to_polygon_shp","title":"dxf_to_polygon_shp","text":"<pre><code>dxf_to_polygon_shp(input_dxf, output_shp, encoding='UTF-8')\n</code></pre> <p>Convertir des polygones d'un fichier DXF en un fichier SHP.</p> <p>:param input_dxf: Chemin vers le fichier DXF d'entr\u00e9e. :param output_shp: Chemin vers le fichier shapefile de sortie. :param encoding: Character encoding le fichier DXF</p>"},{"location":"references/#pymdu.geometric.Dxf2Shp.dxf_to_polygon_shp2","title":"dxf_to_polygon_shp2","text":"<pre><code>dxf_to_polygon_shp2(input_dxf, output_shp, tree_shp)\n</code></pre> <p>Convertir des polygones d'un fichier DXF en deux fichiers SHP : - <code>output_shp</code> pour les polygones g\u00e9n\u00e9raux. - <code>tree_shp</code> pour les arbres identifi\u00e9s.</p> <p>:param input_dxf: Chemin vers le fichier DXF d'entr\u00e9e. :param output_shp: Chemin vers le fichier shapefile de sortie g\u00e9n\u00e9ral. :param tree_shp: Chemin vers le fichier shapefile des arbres.</p>"},{"location":"references/#pymdu.geometric.Dxf2Shp.dxf_to_cosia_and_weighted_layers","title":"dxf_to_cosia_and_weighted_layers","text":"<pre><code>dxf_to_cosia_and_weighted_layers(\n    input_shp_dxf,\n    output_shp_gdf,\n    bbox_coords=None,\n    bbox_crs=\"EPSG:4326\",\n    encoding=\"UTF-8\",\n)\n</code></pre> <p>Convertir des layers d'un fichier DXF en layers Cosia avec poids : :param input_shp_dxf: Chemin vers le fichier SHP d'entr\u00e9e. :param output_shp: Chemin vers le fichier shapefile de sortie :param bbox_coords: choisir le taille :param bbox_crs: le crs du bbox_coords :param encoding: encoding de le fichier SHP</p>"},{"location":"references/#pymdu.geometric.Iris","title":"Iris","text":""},{"location":"references/#pymdu.geometric.Iris.Iris","title":"Iris","text":"<pre><code>Iris(output_path=None)\n</code></pre> <p>               Bases: <code>IgnCollect</code></p> PARAMETER DESCRIPTION <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Example PlotSource code <p> 2025-01-21T17:01:59.903527 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport pymdu.geometric.Iris as Iris\n\niris = Iris(output_path='./')\niris.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\niris = iris.run()\ngdf = iris.to_gdf()\ngdf.plot(ax=plt.gca())\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Isochrone","title":"Isochrone","text":""},{"location":"references/#pymdu.geometric.Isochrone.Isochrone","title":"Isochrone","text":"<pre><code>Isochrone(output_path=None, poi=None, write_geojson=False)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> PARAMETER DESCRIPTION <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>poi</code> <p>The point of interest.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>write_geojson</code> <p>If True, the processed data will be written to a GeoJSON file.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Example PlotSource code <p> 2025-01-21T17:02:03.331614 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport contextily as cx\nimport pymdu.geometric.Isochrone as Isochrone\n\npoi = {'lon': -1.1491, 'lat': 46.1849}\niso = Isochrone(poi=poi)\niso.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\niso.run()\niso_in_gdf, iso_out_gdf = iso.to_gdf()\nt = 15  # 15 minutes\nax = iso_in_gdf.loc[[t]].plot(\n    alpha=0.25, color='black', figsize=(8, 8), label='in'\n)\nax = iso_out_gdf.loc[[t]].plot(alpha=0.25, color='b', ax=ax, label='out')\ncx.add_basemap(\n    ax,\n    source=cx.providers.CartoDB.VoyagerNoLabels,\n    crs=iso_out_gdf.crs.to_string(),\n)\n_ = plt.plot(iso.poi_lam93.x, iso.poi_lam93.y, marker='o', color='red', alpha=1)\n_ = plt.axis('off')\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Isochrone.Isochrone.create_isochrones","title":"create_isochrones","text":"<pre><code>create_isochrones(\n    coords,\n    tt_col=\"tt_out\",\n    x_col=\"x_2154\",\n    y_col=\"y_2154\",\n    steps_m=[10, 20, 30],\n    ratio=0.3,\n    allow_holes=False,\n)\n</code></pre> <p>Create isochrones from travel time data.</p>"},{"location":"references/#pymdu.geometric.Isochrone.Isochrone.create_isochrones--parameters","title":"Parameters","text":"<p>coords : pandas.DataFrame     DataFrame containing coordinates and travel time data. tt_col : str, optional     Name of the column containing travel time data.     The default is \"tt_out\". x_col : str, optional     Name of the column containing x-coordinates.     The default is \"x_2154\". y_col : str, optional     Name of the column containing y-coordinates.     The default is \"y_2154\". steps_m : list of int, optional     List of travel times in minutes for which to create isochrones.     The default is [10, 20, 30]. ratio : float, optional     Ratio of concavity for the isochrones.     The default is 0.3. allow_holes : bool, optional     Whether to allow holes in the isochrones.     The default is False.</p>"},{"location":"references/#pymdu.geometric.Isochrone.Isochrone.create_isochrones--returns","title":"Returns","text":"<p>gdf : geopandas.GeoDataFrame     GeoDataFrame containing the isochrones as polygons.</p>"},{"location":"references/#pymdu.geometric.Isochrone.Isochrone.compute_slope","title":"compute_slope  <code>staticmethod</code>","text":"<pre><code>compute_slope(triangle_att)\n</code></pre> <p>triangle_att must be [tail_z, head_z, length]</p>"},{"location":"references/#pymdu.geometric.IsochroneIGN","title":"IsochroneIGN","text":""},{"location":"references/#pymdu.geometric.IsochroneIGN.IsochroneIGN","title":"IsochroneIGN","text":"<pre><code>IsochroneIGN(\n    output_path=None,\n    resource=\"bdtopo-valhalla\",\n    point=(2.337306, 48.849319),\n    costValue=300,\n    costType=\"time\",\n    set_crs=None,\n)\n</code></pre> <p>               Bases: <code>IgnCollect</code></p> <p>Class to collect the Building data</p> PARAMETER DESCRIPTION <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>resource</code> <p>The resource to use.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'bdtopo-valhalla'</code> </p> <code>point</code> <p>Coordonn\u00e9es d'une position ponctuelle. C'est le point \u00e0 partir duquel seront fait les calculs. Il devra \u00eatre exprim\u00e9 dans le CRS, par d\u00e9faut, de la ressource (voir le param\u00e8tre 'crs' dans le GetCapabilities).</p> <p> TYPE: <code>tuple</code> DEFAULT: <code>(2.337306, 48.849319)</code> </p> <code>costValue</code> <p>The cost value. Valeur du co\u00fbt utilis\u00e9 pour le calcul. Les valeurs disponibles et la valeur par d\u00e9faut utilis\u00e9es sont pr\u00e9sentes dans le GetCapabilities. On pourra, par exemple, pr\u00e9ciser une distance ou un temps, selon l'optimisation choisie. L'unit\u00e9 d\u00e9pendra aussi des param\u00e8tres distanceUnit et timeUnit.</p> <p> TYPE: <code>int</code> DEFAULT: <code>300</code> </p> <code>costType</code> <p>The cost type. Type du co\u00fbt utilis\u00e9 pour le calcul. Les valeurs disponibles et la valeur par d\u00e9faut utilis\u00e9es sont pr\u00e9sentes dans le GetCapabilities. On pourra, par exemple, pr\u00e9ciser une distance ou un temps, selon l'optimisation choisie. L'unit\u00e9 d\u00e9pendra aussi des param\u00e8tres distanceUnit et timeUnit</p> <p> TYPE: <code>str</code> DEFAULT: <code>'time'</code> </p> <code>set_crs</code> <p>The CRS (Coordinate Reference System) to be set.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> Example PlotSource code <p> 2025-01-21T17:02:03.988862 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\n\nimport pymdu.geometric.IsochroneIGN as IsochroneIGN\n\nisochroneIGN = IsochroneIGN(output_path='./')\nisochroneIGN.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nisochroneIGN = isochroneIGN.run()\nisochroneIGN.to_gdf().plot(ax=plt.gca(), edgecolor='black', legend=True)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.LandCover","title":"LandCover","text":""},{"location":"references/#pymdu.geometric.LandCover.LandCover","title":"LandCover","text":"<pre><code>LandCover(\n    building_gdf=None,\n    vegetation_gdf=None,\n    water_gdf=None,\n    pedestrian_gdf=None,\n    cosia_gdf=None,\n    dxf_gdf=None,\n    output_path=None,\n    write_file=True,\n)\n</code></pre> <p>               Bases: <code>GeoCore</code>, <code>BasicFunctions</code></p> <p>classdocs rappel de la d\u00e9finition initiale des classes dans Umep Name              Code Alb  Emis Ts_deg Tstart TmaxLST Roofs(buildings)   2   0.18 0.95 0.58   -9.78  15.0 Dark_asphalt       1   0.18 0.95 0.58   -9.78  15.0 Cobble_stone_2014a 0   0.20 0.95 0.37   -3.41  15.0 Water              7   0.05 0.98 0.00    0.00  12.0 Grass_unmanaged    5   0.16 0.94 0.21   -3.38  14.0 bare_soil          6   0.25 0.94 0.33   -3.01  14.0 Walls             99   0.20 0.90 0.37   -3.41  15.0</p> PARAMETER DESCRIPTION <code>building_gdf</code> <p>gpd.GeoDataFrame = None,</p> <p> TYPE: <code>GeoDataFrame</code> DEFAULT: <code>None</code> </p> <pre><code>vegetation_gdf: gpd.GeoDataFrame = None,\nwater_gdf: gpd.GeoDataFrame = None,\npedestrian_gdf: gpd.GeoDataFrame = None,\ncosia_gdf: gpd.GeoDataFrame = None,\ndxf_gdf: gpd.GeoDataFrame = None,\noutput_path: str = None,\nwrite_file: bool = True,\n</code></pre> Example PlotSource code <p> 2025-01-21T17:02:37.653541 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\nfrom pymdu.image import geotiff\nfrom pymdu.geometric import Vegetation, Pedestrian, Water, Building, LandCover\nfrom pymdu.geometric.Dem import Dem\nfrom pymdu.commons.BasicFunctions import plot_sol_occupancy\nfrom pymdu.GeoCore import GeoCore\n\ngeocore = GeoCore()\ngeocore.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\n\nbuilding = Building(output_path=\"./\")\nbuildings_gdf = building.run().to_gdf()\n# building.to_shp(name='buildings')\n\nwater = Water(output_path=\"./\")\nwater_gdf = water.run().to_gdf()\n# water.to_shp(name='water')\n\npedestrian = Pedestrian(output_path=\"./\")\npedestrian_gdf = pedestrian.run().to_gdf()\n# pedestrian.to_shp(name='pedestrian')\n\nvegetation = Vegetation(output_path=\"./\", min_area=100)\nvegetation_gdf = vegetation.run().to_gdf()\n# vegetation.to_shp(name='vegetation')\n\n# cosia_gdf = gpd.read_file(\"../../demos/demo_cosia_gdf.shp\")\n# dxf_gdf = gpd.read_f  #\ncosia_gdf = None\ndxf_gdf = None\n\nlandcover = LandCover(\noutput_path=\"./\",\nbuilding_gdf=buildings_gdf,\nvegetation_gdf=vegetation_gdf,\nwater_gdf=water_gdf,\ncosia_gdf=cosia_gdf,\ndxf_gdf=dxf_gdf,\npedestrian_gdf=pedestrian_gdf,\nwrite_file=False,\n)\n\nlandcover.run()\n# landcover.to_shp(name=\"landcover\")\nlandcover_gdf = landcover.to_gdf()\n\nfig, ax = plt.subplots(figsize=(10, 10))\n\nif cosia_gdf is not None:\n    landcover_gdf.plot(color=landcover_gdf[\"color\"])\n    fig_hist = plot_sol_occupancy(cosia_gdf, landcover_gdf)\n    fig_hist.show()\nelse:\n    landcover_gdf.plot(ax=plt.gca(), edgecolor=\"black\", column=\"type\")\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.LandCover.LandCover.create_landcover_from_cosia","title":"create_landcover_from_cosia","text":"<pre><code>create_landcover_from_cosia(\n    dst_tif=\"landcover.tif\", template_raster_path=None\n)\n</code></pre> <p>cr\u00e9e le fichier tif du gdf de couverture du sol COSIA dst_tif: le fichier output</p>"},{"location":"references/#pymdu.geometric.Lcz","title":"Lcz","text":""},{"location":"references/#pymdu.geometric.Lcz.Lcz","title":"Lcz","text":"<pre><code>Lcz(filepath_shp=None, output_path=None, set_crs=None)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> <p>Class to collect the Building data</p> PARAMETER DESCRIPTION <code>filepath_shp</code> <p>The file path to the shapefile.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>set_crs</code> <p>The CRS (Coordinate Reference System) to be set.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> Example PlotSource code <p> 2025-01-21T17:02:41.111345 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\nimport pymdu.geometric.Lcz as Lcz\n\nlcz = Lcz()\nlcz_gdf = lcz.run().to_gdf()\nlcz.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\ntable_color = lcz.table_color\nfig, ax = plt.subplots(figsize=(10, 10))\nlcz_gdf.plot(ax=ax, edgecolor=None, color=lcz_gdf['color'])\npatches = [\n    mpatches.Patch(color=info[1], label=info[0])\n    for info in table_color.values()\n]\nplt.legend(\n    handles=patches,\n    loc='upper right',\n    title='LCZ Legend',\n    bbox_to_anchor=(1.1, 1.0),\n)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Pedestrian","title":"Pedestrian","text":""},{"location":"references/#pymdu.geometric.Pedestrian.Pedestrian","title":"Pedestrian","text":"<pre><code>Pedestrian(filepath_shp=None, output_path=None)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> <p>Class to collect the Pedestrian data</p> PARAMETER DESCRIPTION <code>filepath_shp</code> <p>The file path to the shapefile.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Example PlotSource code <p> 2025-01-21T17:02:41.263223 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport h3pandas\n\nimport pymdu.geometric.Pedestrian as Pedestrian\n\npedestrian = Pedestrian(output_path='./')\npedestrian.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\npedestrian.run()\ngdf = pedestrian.to_gdf()\npoint_arbres = pedestrian.tree_position(\n    pedestrian=pedestrian.gdf,\n    resolution=11,\n    height=6.0,\n    type=2,\n    trunk_zone=3.0,\n)\ngdf.plot(ax=plt.gca(), edgecolor='black')\n# point_arbres.plot(color='red', markersize=10)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Pedestrian.Pedestrian.tree_position","title":"tree_position  <code>staticmethod</code>","text":"<pre><code>tree_position(\n    pedestrian,\n    resolution=11,\n    height=6.0,\n    type=2,\n    trunk_zone=3.0,\n    diameter=4.0,\n)\n</code></pre> PARAMETER DESCRIPTION <code>diameter</code> <p> TYPE: <code>float</code> DEFAULT: <code>4.0</code> </p> <code>height</code> <p> TYPE: <code>float</code> DEFAULT: <code>6.0</code> </p> <code>type</code> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>trunk_zone</code> <p> TYPE: <code>float</code> DEFAULT: <code>3.0</code> </p> <code>pedestrian</code> <p>le geodataframe de la zone pi\u00e9tonne</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>resolution</code> <p>la r\u00e9solution pour le d\u00e9coupage hexagonal</p> <p> TYPE: <code>int</code> DEFAULT: <code>11</code> </p> <p>Returns: geodataframe de la position des arbres</p>"},{"location":"references/#pymdu.geometric.Rnb","title":"Rnb","text":""},{"location":"references/#pymdu.geometric.Rnb.Rnb","title":"Rnb","text":"<pre><code>Rnb(output_path=None)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> PARAMETER DESCRIPTION <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Example PlotSource code <p> 2025-01-21T17:02:42.321174 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport pymdu.geometric.Building as Building\nimport pymdu.geometric.Rnb as Rnb\n\nrnb = Rnb(output_path='./')\nrnb.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nrnb = rnb.run()\nrnb_gdf = rnb.to_gdf()\nbuildings = Building(output_path='./')\nbuildings.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nbuildings_gdf = buildings.run().to_gdf()\nax = rnb_gdf.plot(ax=plt.gca(), edgecolor='black', color='red')\nbuildings_gdf.plot(ax=ax, edgecolor='black', alpha=0.5)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Road","title":"Road","text":""},{"location":"references/#pymdu.geometric.Road.Road","title":"Road","text":"<pre><code>Road(output_path=None)\n</code></pre> <p>               Bases: <code>IgnCollect</code></p> <p>Class to collect the Road data</p> PARAMETER DESCRIPTION <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> Example PlotSource code <p> 2025-01-21T17:02:43.237999 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport pymdu.geometric.Road as Road\n\nroad = Road(output_path='./')\nroad.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nroad = road.run()\nroad_gdf = road.to_gdf()\nax = road_gdf.plot(ax=plt.gca(), edgecolor='black', color='red')\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.SkyFactor","title":"SkyFactor","text":""},{"location":"references/#pymdu.geometric.SkyFactor.SkyFactor","title":"SkyFactor","text":"<pre><code>SkyFactor(buildings_gdf, elevationFieldname='hauteur')\n</code></pre> <p>               Bases: <code>GeoCore</code></p> <p>classdocs</p> PARAMETER DESCRIPTION <code>buildings_gdf</code> <p>GeoDataFrame of the buildings.</p> <p> TYPE: <code>GeoDataFrame</code> </p> <code>elevationFieldname</code> <p>Name of the elevation field.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'hauteur'</code> </p> Example PlotSource code <p> 2025-01-21T17:03:37.918512 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport pymdu.geometric.SkyFactor as SkyFactor\nimport pymdu.geometric.Building as Building\n\nbuilding = Building(output_path='./')\nbuildings_gdf = building.run().to_gdf()\nsky_factor = SkyFactor(\n    buildings_gdf=buildings_gdf, elevationFieldname='hauteur'\n)\nsky_factor.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nsky_factor = sky_factor.run()\nsky_factor_gdf = sky_factor.to_gdf()\n_, basemap = plt.subplots(figsize=(8.26, 8.26))\nbasemap.set_title('Sky View Factor', fontsize=16)\nplt.axis('off')\nbuildings_gdf.plot(ax=basemap, color='grey')\nsky_factor_gdf.plot(\n    ax=basemap, column='svf', markersize=8, legend=True, cmap='viridis'\n)\nplt.legend(loc='upper right', framealpha=0.5)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.UrockFiles","title":"UrockFiles","text":""},{"location":"references/#pymdu.geometric.UrockFiles.UrockFiles","title":"UrockFiles","text":"<pre><code>UrockFiles(\n    output_path=None, buildings_gdf=None, trees_gdf=None\n)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> <p>classdocs</p>"},{"location":"references/#pymdu.geometric.UrockFiles.UrockFiles.generate_urock_buildings","title":"generate_urock_buildings","text":"<pre><code>generate_urock_buildings(filename_shp='urock_bld.shp')\n</code></pre> <p>Returns:</p>"},{"location":"references/#pymdu.geometric.UrockFiles.UrockFiles.generate_urock_trees","title":"generate_urock_trees","text":"<pre><code>generate_urock_trees(\n    filename_shp=\"urock_trees.shp\",\n    size=6,\n    ID_VEG=5,\n    MIN_HEIGHT=2.2,\n    MAX_HEIGHT=5.8,\n    ATTENUATIO=2.8,\n)\n</code></pre> <p>Returns:</p>"},{"location":"references/#pymdu.geometric.Vegetation","title":"Vegetation","text":""},{"location":"references/#pymdu.geometric.Vegetation.Vegetation","title":"Vegetation","text":"<pre><code>Vegetation(\n    filepath_shp=None,\n    output_path=None,\n    set_crs=None,\n    write_file=False,\n    min_area=0,\n)\n</code></pre> <p>               Bases: <code>IgnCollect</code></p> <p>Class to collect the Vegetation data</p> PARAMETER DESCRIPTION <code>filepath_shp</code> <p>(str) The path to the shapefile to be processed. If not provided, the data will be read from the input file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>set_crs</code> <p>(int) The EPSG code to set the CRS of the output file. If not provided, the CRS of the input file will be used.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>write_file</code> <p>(bool) If True, the output file will be written to disk. If False, the output file will be returned.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>min_area</code> <p>(float) The minimum area of the polygons to be considered as vegetation. If not provided, the minimum area will be set to 0.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> Example PlotSource code <p> 2025-01-21T17:03:47.703788 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport pymdu.geometric.Vegetation as Vegetation\n\nvegetation = Vegetation(output_path='./')\nvegetation.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nvegetation = vegetation.run()\ngdf = vegetation.to_gdf()\ngdf.plot(ax=plt.gca(), edgecolor='black', color='green', alpha=0.5)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.geometric.Water","title":"Water","text":""},{"location":"references/#pymdu.geometric.Water.Water","title":"Water","text":"<pre><code>Water(filepath_shp=None, output_path=None, set_crs=None)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> <p>=== Classe qui permet - de construire une req\u00fbete pour interroger l'API de l'IGN - enregistre les donn\u00e9es dans le dossier ./demo/ ===</p> PARAMETER DESCRIPTION <code>filepath_shp</code> <p>(str) The path to the shapefile to be processed. If not provided, the data will be read from the input file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>output_path</code> <p>The output path for the processed data. If not provided, a default temporary path will be used.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>set_crs</code> <p>(int) The EPSG code to set the CRS of the output file. If not provided, the CRS of the input file will be used.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> Example PlotSource code <p> 2025-01-21T17:03:48.741409 image/svg+xml Matplotlib v3.10.0, https://matplotlib.org/ </p> <pre><code>import matplotlib.pyplot as plt\nimport pymdu.geometric.Water as Water\n\nwater = Water(output_path='./')\nwater.bbox = [-1.152704, 46.181627, -1.139893, 46.18699]\nwater = water.run()\ngdf = water.to_gdf()\ngdf.plot(ax=plt.gca(), edgecolor='black', color='blue', alpha=0.5)\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdumeteo","title":"pymdu.meteo","text":"pymdu.meteo"},{"location":"references/#pymdu.meteo","title":"pymdu.meteo","text":""},{"location":"references/#pymdu.meteo.Meteo","title":"Meteo","text":""},{"location":"references/#pymdu.meteo.Meteo.Meteo","title":"Meteo","text":"<pre><code>Meteo(output_path=None)\n</code></pre> <p>               Bases: <code>GeoCore</code></p>"},{"location":"references/#pymdu.meteo.Meteo.Meteo.gen_umep_weather_from_list","title":"gen_umep_weather_from_list","text":"<pre><code>gen_umep_weather_from_list(\n    listofdays,\n    epw_file=\"LaRochelle_historical_IPSL_bc_type.epw\",\n    init_weather_file=\"base_weather.txt\",\n    compute_night=True,\n)\n</code></pre> <p>TODO : mieux d\u00e9finir les jours/nuits</p> PARAMETER DESCRIPTION <code>listofdays</code> <p> </p> <code>epw_file</code> <p> DEFAULT: <code>'LaRochelle_historical_IPSL_bc_type.epw'</code> </p> <code>init_weather_file</code> <p> DEFAULT: <code>'base_weather.txt'</code> </p> <code>compute_night</code> <p> DEFAULT: <code>True</code> </p>"},{"location":"references/#pymduphysicsumep","title":"pymdu.physics.umep","text":"pymdu.physics.umep"},{"location":"references/#pymdu.physics.umep","title":"pymdu.physics.umep","text":""},{"location":"references/#pymdu.physics.umep.DsmModelGenerator","title":"DsmModelGenerator","text":""},{"location":"references/#pymdu.physics.umep.DsmModelGenerator.DsmModelGenerator","title":"DsmModelGenerator","text":"<pre><code>DsmModelGenerator(\n    working_directory,\n    output_filepath_dsm=\"DSM.tif\",\n    input_filepath_dem=\"DEM.tif\",\n    input_building_shp_path=\"buildings.shp\",\n    input_mask_shp_path=\"mask.shp\",\n)\n</code></pre> <p>               Bases: <code>UmepCore</code></p> PARAMETER DESCRIPTION <code>input_solweig_path</code> <p>The path to the input Solweig file.</p> <p> TYPE: <code>path</code> </p> RETURNS DESCRIPTION <p>None</p>"},{"location":"references/#pymdu.physics.umep.HeightAspectModelGenerator","title":"HeightAspectModelGenerator","text":""},{"location":"references/#pymdu.physics.umep.HeightAspectModelGenerator.HeightAspectModelGenerator","title":"HeightAspectModelGenerator","text":"<pre><code>HeightAspectModelGenerator(\n    working_directory,\n    input_filepath_dsm=\"DSM.tif\",\n    output_filepath_aspect=\"ASPECT.tif\",\n    output_filepath_height=\"HEIGHT.tif\",\n)\n</code></pre> <p>               Bases: <code>UmepCore</code></p> <p>Args:</p> RETURNS DESCRIPTION <p>None</p>"},{"location":"references/#pymdu.physics.umep.SVFModelGenerator","title":"SVFModelGenerator","text":""},{"location":"references/#pymdu.physics.umep.SVFModelGenerator.SVFModelGenerator","title":"SVFModelGenerator","text":"<pre><code>SVFModelGenerator(\n    working_directory,\n    input_filepath_dsm=\"DSM.tif\",\n    input_filepath_dem=\"DEM.tif\",\n    input_filepath_cdsm=\"CDSM.tif\",\n    input_filepath_tdsm=\"TDSM.tif\",\n    ouptut_filepath_svf=\"SVF.tif\",\n)\n</code></pre> <p>               Bases: <code>UmepCore</code></p> <p>Args:</p> RETURNS DESCRIPTION <p>None</p>"},{"location":"references/#pymdu.physics.umep.Solweig","title":"Solweig","text":""},{"location":"references/#pymdu.physics.umep.Solweig.Solweig","title":"Solweig","text":"<pre><code>Solweig(\n    meteo_path,\n    output_dir,\n    working_directory,\n    input_filepath_landcover=\"landcover.tif\",\n    input_filepath_dsm=\"DSM.tif\",\n    input_filepath_dem=\"DEM.tif\",\n    input_filepath_cdsm=\"CDSM.tif\",\n    input_filepath_tdsm=\"TDSM.tif\",\n    input_filepath_height=\"HEIGHT.tif\",\n    input_filepath_aspect=\"ASPECT.tif\",\n    input_filepath_shadowmats_npz=\"shadowmats.npz\",\n    input_filepath_svf_zip=\"svfs.zip\",\n)\n</code></pre> <p>               Bases: <code>UmepCore</code></p> PARAMETER DESCRIPTION <code>input_solweig_path</code> <p>The path to the input solweig file.</p> <p> TYPE: <code>path</code> </p> <code>meteo_path</code> <p>The path to the meteo file.</p> <p> TYPE: <code>path</code> </p> <code>output_dir</code> <p>The path to the output directory.</p> <p> TYPE: <code>path</code> </p>"},{"location":"references/#pymdu.physics.umep.SurfaceModelGenerator","title":"SurfaceModelGenerator","text":""},{"location":"references/#pymdu.physics.umep.SurfaceModelGenerator.SurfaceModelGenerator","title":"SurfaceModelGenerator","text":"<pre><code>SurfaceModelGenerator(\n    working_directory,\n    input_filepath_dsm=\"DSM.tif\",\n    input_filepath_dem=\"DEM.tif\",\n    input_filepath_tree_shp=\"trees.shp\",\n    output_filepath_cdsm=\"CDSM.tif\",\n    output_filepath_tdsm=\"TDSM.tif\",\n)\n</code></pre> <p>               Bases: <code>UmepCore</code></p> PARAMETER DESCRIPTION <code>input_solweig_path</code> <p>The path to the input Solweig file.</p> <p> TYPE: <code>path</code> </p> RETURNS DESCRIPTION <p>None</p>"},{"location":"references/#pymduimage","title":"pymdu.image","text":"pymdu.image <p>Generated by MkDocs</p>"},{"location":"references/#pymdu.image","title":"pymdu.image","text":""},{"location":"references/#pymdu.image.Lidar","title":"Lidar","text":""},{"location":"references/#pymdu.image.Lidar.Lidar","title":"Lidar","text":"<pre><code>Lidar(output_path=None, classification=None)\n</code></pre> <p>               Bases: <code>GeoCore</code></p> PARAMETER DESCRIPTION <code>building_gdf</code> <p>gpd.GeoDataFrame = None,</p> <p> </p> <pre><code>vegetation_gdf: gpd.GeoDataFrame = None,\nwater_gdf: gpd.GeoDataFrame = None,\npedestrian_gdf: gpd.GeoDataFrame = None,\ncosia_gdf: gpd.GeoDataFrame = None,\ndxf_gdf: gpd.GeoDataFrame = None,\noutput_path: str = None,\nwrite_file: bool = True,\n</code></pre> Example <pre><code>Traceback (most recent call last):\n  File \"/Users/Boris/miniforge3/envs/umep_pymdu/lib/python3.11/site-packages/markdown_exec/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/Users/Boris/miniforge3/envs/umep_pymdu/lib/python3.11/site-packages/markdown_exec/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n17&gt;\", line 10, in &lt;module&gt;\n    from pymdu.geometric.Lidar import Lidar\nModuleNotFoundError: No module named 'pymdu.geometric.Lidar'\n</code></pre> Todo <ul> <li>For module TODOs</li> </ul>"},{"location":"references/#pymdu.image.Lidar.Lidar.merge_tifs","title":"merge_tifs","text":"<pre><code>merge_tifs(input_files, dsm_out, write_out_file=False)\n</code></pre> <p>Merge multiple GeoTIFF files into a single GeoTIFF file.</p> PARAMETER DESCRIPTION <code>dsm_out</code> <p>Path to the output GeoTIFF file.</p> <p> TYPE: <code>FilePath</code> </p> <code>write_out_file</code> <p>If True, write the merged GeoTIFF file. Otherwise, return a MemoryFile.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>input_files</code> <p>List of paths to input GeoTIFF files.</p> <p> TYPE: <code>list</code> </p>"},{"location":"references/#pymdu.image.geotiff","title":"geotiff","text":""},{"location":"references/#pymdu.image.geotiff.resample_resolution","title":"resample_resolution","text":"<pre><code>resample_resolution(\n    src_tif=None, dst_tif=None, new_xres=1, new_yres=-1\n)\n</code></pre> <p>resample resolution the pixel size of the raster.</p> PARAMETER DESCRIPTION <code>new_xres</code> <p>desired resolution in x-direction</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>new_yres</code> <p>desired resolution in y-direction</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <code>save_path</code> <p>filepath to where the output file should be stored</p> <p> TYPE: <code>str</code> </p> <p>Returns: Nothing, it writes a raster file with decreased resolution. :param new_yres: :param new_xres:</p>"},{"location":"references/#pymdu.image.geotiff.reproject","title":"reproject","text":"<pre><code>reproject(\n    src_tif=None,\n    dst_tif=None,\n    src_epsg=3857,\n    dist_epsg=2154,\n)\n</code></pre> <p>resample resolution the pixel size of the raster.</p> PARAMETER DESCRIPTION <code>new_xres</code> <p>desired resolution in x-direction</p> <p> TYPE: <code>int</code> </p> <code>new_yres</code> <p>desired resolution in y-direction</p> <p> TYPE: <code>int</code> </p> <code>save_path</code> <p>filepath to where the output file should be stored</p> <p> TYPE: <code>str</code> </p> <p>Returns: Nothing, it writes a raster file with decreased resolution. :param new_yres: :param new_xres:</p>"},{"location":"references/#pymdu.image.geotiff.resample_size","title":"resample_size","text":"<pre><code>resample_size(\n    src_tif=None, dst_tif=None, new_width=1, new_height=-1\n)\n</code></pre> <p>resample size of the raster.</p> PARAMETER DESCRIPTION <code>new_width</code> <p>desired width</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>new_height</code> <p>desired height</p> <p> TYPE: <code>int</code> DEFAULT: <code>-1</code> </p> <p>Returns: Nothing, it writes a raster file with decreased resolution. :param save_path: :param new_height: :param new_width:</p>"},{"location":"references/#pymdu.image.geotiff.resample_projection","title":"resample_projection","text":"<pre><code>resample_projection(\n    src_tif=None, dst_tif=None, new_epsg=2154\n)\n</code></pre> <p>resample projection of the raster.</p> PARAMETER DESCRIPTION <code>new_epsg</code> <p>desired epsg</p> <p> TYPE: <code>int</code> DEFAULT: <code>2154</code> </p> <code>save_path</code> <p>filepath to where the output file should be stored</p> <p> TYPE: <code>str</code> </p> <p>Returns: Nothing, it writes a raster file with decreased resolution. :param save_path: :param new_epsg:</p>"},{"location":"references/#pymdu.image.geotiff.toto","title":"toto","text":"<pre><code>toto(src_tif, dst_tif='output.tif')\n</code></pre> RETURNS DESCRIPTION <code>object</code>"},{"location":"references/#pymdu.image.geotiff.raster_to_gdf","title":"raster_to_gdf","text":"<pre><code>raster_to_gdf(src_tif, new_field_name='elevation')\n</code></pre> RETURNS DESCRIPTION <code>object</code> <p> TYPE: <code>GeoDataFrame</code> </p>"},{"location":"references/#pymdu.image.geotiff.gdf_to_raster","title":"gdf_to_raster","text":"<pre><code>gdf_to_raster(\n    gdf,\n    dst_tif,\n    measurement,\n    categorical=False,\n    resolution=(-0.03, 0.03),\n    raster_file_like=None,\n    fill_value=None,\n    dtype=\"float64\",\n)\n</code></pre> PARAMETER DESCRIPTION <code>dst_tif</code> <code>measurement</code> <p> TYPE: <code>str</code> </p> <code>dtype</code> <p> DEFAULT: <code>'float64'</code> </p> <code>fill_value</code> <p> DEFAULT: <code>None</code> </p> <code>gdf</code> <p> TYPE: <code>GeoDataFrame</code> </p> <code>categorical</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>resolution</code> <p> TYPE: <code>tuple</code> DEFAULT: <code>(-0.03, 0.03)</code> </p> <code>raster_file_like</code> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p>"},{"location":"references/#pymdu.image.geotiff.reproject_resample_cropped_raster","title":"reproject_resample_cropped_raster","text":"<pre><code>reproject_resample_cropped_raster(\n    model_file, src_tif, dst_tif=\"optionnal\"\n)\n</code></pre> PARAMETER DESCRIPTION <code>model_file</code> <p>le raster .tif dont les caract\u00e9ristiques doivent \u00eatre copi\u00e9es</p> <p> </p> <code>input_file</code> <p>le fichier raster .tif d'entr\u00e9e</p> <p> </p> <code>output_file</code> <p>le du raster .tif nom que l'on souhaite donner \u00e0 la sortie</p> <p> </p>"},{"location":"references/#pymdu.image.geotiff.tiff_to_jp2","title":"tiff_to_jp2","text":"<pre><code>tiff_to_jp2(\n    src_tif,\n    output=\"output.jp2\",\n    openjpeg_base_path=\"/Users/Boris/anaconda3/envs/pymdu/bin\",\n)\n</code></pre> RETURNS DESCRIPTION <code>object</code>"},{"location":"references/#pymdu.image.rasterize","title":"rasterize","text":"<p>rasterize</p>"},{"location":"references/#pymdu.image.rasterize.pc_to_dsm","title":"pc_to_dsm  <code>builtin</code>","text":"<pre><code>pc_to_dsm()\n</code></pre> <p>pc_to_dsm(points: numpy.ndarray[numpy.float64], values: numpy.ndarray[numpy.float64], valid: numpy.ndarray[numpy.int32], xstart: float, ystart: float, xsize: int, ysize: int, resolution: float, radius: int, sigma: float) -&gt; tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray]</p> <p>Convert point cloud to digital surface model</p>"}]}